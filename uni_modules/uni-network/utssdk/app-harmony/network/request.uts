import http from '@ohos.net.http'
import {
    isPlainObject,
    Emitter,
} from '@dcloudio/uni-runtime'
import {
    RequestTask as UniRequestTask,
    RequestOptions as UniRequestOptions,
    RequestSuccess as UniRequestSuccess,
    Request
} from '../../interface.uts'
import {
    API_REQUEST,
    RequestApiOptions,
    RequestApiProtocol,
} from '../../protocol.uts'
import {
    parseUrl
} from './utils.uts'

// copy from uni-app-plus/src/service/api/network/request.ts
const cookiesParse = (header: Record<string, string>) => {
    let cookiesArr: string[] = []
    const handleCookiesArr = (header['Set-Cookie'] || header['set-cookie'] || []) as string[]
    for (let i = 0; i < handleCookiesArr.length; i++) {
        if (
            handleCookiesArr[i].indexOf('Expires=') !== -1 ||
            handleCookiesArr[i].indexOf('expires=') !== -1
        ) {
            cookiesArr.push(handleCookiesArr[i].replace(',', ''))
        } else {
            cookiesArr.push(handleCookiesArr[i])
        }
    }
    cookiesArr = cookiesArr.join(';').split(',')
    return cookiesArr
}

interface IRequestTask {
    abort: Function
    onHeadersReceived: Function
    offHeadersReceived: Function
}

class RequestTask implements UniRequestTask {
    private _requestTask: IRequestTask
    constructor(requestTask: IRequestTask) {
        this._requestTask = requestTask
    }
    abort() {
        this._requestTask.abort()
    }
    onHeadersReceived(callback: Function) {
        this._requestTask.onHeadersReceived(callback)
    }
    offHeadersReceived(callback?: Function) {
        this._requestTask.offHeadersReceived(callback)
    }
}

export const request = defineTaskApi<UniRequestOptions<Object>, UniRequestSuccess<Object>, UniRequestTask>(
    API_REQUEST,
    (args: UniRequestOptions<Object>, exec: ApiExecutor<UniRequestSuccess<Object>>) => {
        let { header, method, data, dataType, timeout, url, responseType } = args

        let contentType = ''

        // header
        const headers = {} as Record<string, Object>
        if (header) {
            const headerRecord = header as Object as Record<string, string>
            const headerKeys = Object.keys(headerRecord)
            for (let i = 0; i < headerKeys.length; i++) {
                const name = headerKeys[i];
                if (name.toLowerCase() === 'content-type') {
                    contentType = headerRecord[name] as string
                }
                headers[name.toLowerCase()] = headerRecord[name]
            }
        }

        if (!contentType && method === 'POST') {
            headers['Content-Type'] = 'application/json'
            contentType = 'application/json'
        }

        // url data
        if (method === 'GET' && data && isPlainObject(data)) {
            const dataRecord = data as Record<string, Object>
            const query = Object.keys(dataRecord)
                .map((key) => {
                    return (
                        encodeURIComponent(key) +
                        '=' +
                        encodeURIComponent(dataRecord[key] as string | number | boolean)
                    )
                })
                .join('&')
            url += query ?
                (url.indexOf('?') > -1 ? '&' : '?') + query :
                ''
            data = null
        } else if (
            method !== 'GET' &&
            contentType &&
            contentType.indexOf('application/json') === 0 &&
            isPlainObject(data)
        ) {
            data = JSON.stringify(data)
        } else if (
            method !== 'GET' &&
            contentType &&
            contentType.indexOf('application/x-www-form-urlencoded') === 0 &&
            isPlainObject(data)
        ) {
            const dataRecord = data as Record<string, Object>
            data = Object.keys(dataRecord)
                .map((key) => {
                    return (
                        encodeURIComponent(key) +
                        '=' +
                        encodeURIComponent(dataRecord[key] as number | string | boolean)
                    )
                })
                .join('&')
        }

        // 其他参数
        let expectDataType: http.HttpDataType = http.HttpDataType.STRING
        if (responseType === 'arraybuffer') {
            expectDataType = http.HttpDataType.ARRAY_BUFFER
        } else if (dataType === 'json') {
            // TODO API 11 http.HttpDataType.OBJECT部分场景下有Bug改为自行parse
            expectDataType = http.HttpDataType.STRING
        } else {
            expectDataType = http.HttpDataType.STRING
        }

        const httpRequest = http.createHttp()
        const emitter = new Emitter()
        const requestTask: IRequestTask = {
            abort() {
                httpRequest.destroy()
            },
            onHeadersReceived(callback: Function) {
                emitter.on('headersReceive', callback)
            },
            offHeadersReceived(callback?: Function) {
                emitter.off('headersReceive', callback)
            },
        }

        httpRequest.on('headersReceive', (header: Object) => {
            // TODO headersReceive在重定向时会多次触发，这点与微信不同，暂不支持回调给用户
            // emitter.emit('headersReceive', header);
        })
        httpRequest.request(
            parseUrl(url),
            {
                header: headers,
                method: (method || 'GET').toUpperCase() as http.RequestMethod, // 仅OPTIONS不支持
                extraData: data || undefined, // 传空字符串会报错
                expectDataType,
                connectTimeout: timeout ? timeout : undefined, // 不支持仅设置一个timeout
                readTimeout: timeout ? timeout : undefined,
            } as http.HttpRequestOptions,
            (err, res) => {
                if (err) {
                    /**
                     * TODO abort后此处收到如下错误，待确认是否直接将此错误码转为abort错误
                     * {"code":2300023,"message":"Failed writing received data to disk/application"}
                     * 
                     * reject方法第二个参数可以传errCode，reject(err.message, { errCode: -1 })
                     */
                    exec.reject(err.message)
                } else {
                    let data = res.result
                    if (dataType === 'json' && typeof data === 'string') {
                        try {
                            data = JSON.parse(data)
                        } catch (e) {
                            // 与微信保持一致，不抛出异常
                        }
                    }
                    exec.resolve({
                        data,
                        statusCode: res.responseCode,
                        header: res.header,
                        cookies: cookiesParse(res.header as Record<string, string>),
                    } as UniRequestSuccess<Object>)
                }
                requestTask.offHeadersReceived()
                httpRequest.destroy() // 调用完毕后必须调用destroy方法
            }
        )
        return new RequestTask(requestTask)
    },
    RequestApiProtocol,
    RequestApiOptions
) as Request<Object>
