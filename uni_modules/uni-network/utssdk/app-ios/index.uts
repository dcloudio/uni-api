import { Request, RequestOptions, RequestSuccess, RequestFail, RequestTask, UploadFileOptions, UploadFile, UploadTask, OnProgressUpdateResult, UploadFileSuccess, UploadFileProgressUpdateCallback, DownloadFileProgressUpdateCallback, DownloadFileOptions, OnProgressDownloadResult, DownloadFile ,DownloadFileSuccess} from './interface';
import { NetworkManager, NetworkRequestListener, NetworkUploadFileListener, NetworkDownloadFileListener } from './network/NetworkManager.uts'
import { Data, HTTPURLResponse, NSError, NSNumber, ComparisonResult, RunLoop, Thread } from 'Foundation';
import { StatusCode } from './network/StatusCode.uts';
import { RequestFailImpl, UploadFileFailImpl, DownloadFileFailImpl, getErrcode } from '../unierror';

class SimpleNetworkListener extends NetworkRequestListener {
	private param : RequestOptions | null = null;
	private headers : Map<string, any> | null = null;
	private received : number = 0;
	private data : Data = new Data();
	constructor(param : RequestOptions) {
		this.param = param;
		super();
	}

	public override onStart() : void {
	}

	public override onHeadersReceived(statusCode : number, headers : Map<string, any>) : void {
		this.headers = headers;
	}
	public override onDataReceived(data : Data) : void {
		this.received += Number.from(data.count);
		this.data.append(data);
	}

	public override onFinished(response : HTTPURLResponse) : void {
		try {
			let headers = response.allHeaderFields as Map<string, any>;
			let kParam = this.param;
			let result = {};
			result['statusCode'] = response.statusCode;
			result['statusText'] = StatusCode.getStatus(new String(response.statusCode));
			if (headers != null) {
				result['header'] = headers;
			}
			let strData = this.readStringFromData(this.data, response.textEncodingName);


			let type = kParam?.responseType != null ? kParam?.responseType : kParam?.dataType;

			if (type == null && headers != null) {

				for (entry in headers) {
					let key = entry.key;
					if (key.caseInsensitiveCompare("Content-Type") == ComparisonResult.orderedSame) {
						type = headers[key] as string;
					}
				}
			}


			result['data'] = this.parseData(this.data, strData, type);

			let tmp : RequestSuccess = {
				data: result['data']!,
				statusCode: (new NSNumber(value = response.statusCode)),
				header: result['header'] ?? "",
				cookies: this.parseCookie(this.headers)
			};
			let success = kParam?.success;
			let complete = kParam?.complete;
			success?.(tmp);
			complete?.(tmp);
		} catch (e) {
		}
	}

	public override onFail(error : NSError) : void {
		let kParam = this.param;
		let code = (error as NSError).code;
		let errCode = code;
		let cause = error.localizedDescription;
		if (code == -1001) {
			errCode = 5;
		} else if (code == -1004) {
			errCode = 1000;
		} else if (code == -1009) {
			errCode = 600003;
		} else {
			errCode = 602001;
		}
		
		let failResult = new RequestFailImpl(getErrcode(Number.from(errCode)));
		failResult.cause = new SourceError(cause);

		let fail = kParam?.fail;
		let complete = kParam?.complete;
		fail?.(failResult);
		complete?.(failResult);
	}


	private readStringFromData(data : Data, type : string | null) : string | null {
		let result : string | null = null;
		let finalType = type;
		if (finalType == null || finalType!.length == 0) {
			finalType = "utf-8";
		}

		let cfEncoding = CFStringConvertIANACharSetNameToEncoding(finalType as CFString);
		if (cfEncoding != kCFStringEncodingInvalidId) {
			let stringEncoding = CFStringConvertEncodingToNSStringEncoding(cfEncoding);
			let encode = new String.Encoding(rawValue = stringEncoding);
			result = new String(data = data, encoding = encode);
		}
		return result;
	}

	private parseData(data : Data | null, dataStr : string | null, type : string | null) : any | null {
		if (type != null && type!.contains("json")) {
			if (dataStr == null || dataStr!.length == 0) {
				return {};
			}
			return this.parseJson(dataStr!);
		} else if (type == 'jsonp') {
			if (dataStr == null || dataStr!.length == 0) {
				return {};
			}
			let start = dataStr!.indexOf('(');
			let end = dataStr!.indexOf(')');
			if (start == 0 || start >= end) {
				return {};
			}
			start += 1;
			let tmp = dataStr!.slice(start, end);
			return this.parseJson(tmp);
		} else {
			//dataStr如果解码失败是空的时候，还需要继续尝试解码。极端情况，服务器不是utf8的，所以字符解码会出现乱码，所以特殊处理一下非utf8的字符。
			if (data == null) {
				return data;
			}

			let currentStr : string | null = dataStr;
			//todo 等uts支持swift文件混编的时候，再进行处理。
			// if (currentStr == null) {
			// 	let data = cleanUTF8(data);
			// 	if (data != null) {
			// 		currentStr = new String(data = data, encoding = String.Encoding.utf8);
			// 	}
			// }

			if (currentStr == null) {
				currentStr = new String(data = data!, encoding = String.Encoding.ascii);
			}

			return currentStr;
		}
	}


	private parseJson(str : string) : any | null {
		return JSON.parse(str);
	}

	private parseCookie(header : Map<string, any> | null) : string[] {
		if (header == null) {
			return []
		}
		let cookiesStr = header!.get('Set-Cookie') as string | null
		if (cookiesStr == null) {
			cookiesStr = header!.get('set-cookie') as string | null
		}
		if (cookiesStr == null) {
			return []
		}
		let cookiesArr = new Array<string>()
		if (cookiesStr!.charAt(0) == "[" && cookiesStr!.charAt(cookiesStr!.length - 1) == "]") {
			cookiesStr = cookiesStr!.slice(1, -1)
		}

		const handleCookiesArr = cookiesStr!.split(';')
		for (let i = 0; i < handleCookiesArr.length; i++) {
			if (handleCookiesArr[i].indexOf('Expires=') != -1 || handleCookiesArr[i].indexOf('expires=') != -1) {
				cookiesArr.push(handleCookiesArr[i].replace(',', ''))
			} else {
				cookiesArr.push(handleCookiesArr[i])
			}
		}
		cookiesArr = cookiesArr.join(';').split(',')

		return cookiesArr
	}
}

class UploadNetworkListener implements NetworkUploadFileListener {
	private param : UploadFileOptions | null = null;
	public progressListeners : Array<UploadFileProgressUpdateCallback> = [];
	private data : Data = new Data();

	constructor(param : UploadFileOptions) {
		this.param = param;
		super();
	}

	onProgress(progressUpdate : OnProgressUpdateResult) {
		if (this.progressListeners.length != 0) {
			for (let i = 0; i < this.progressListeners.length; i++) {
				let listener = this.progressListeners[i];
				listener(progressUpdate)
			}
		}
	}

	onDataReceived(data : Data) : void {
		this.data.append(data);
	}

	onFinished(response : HTTPURLResponse) : void {
		try {
			let kParam = this.param;
			let strData = this.readStringFromData(this.data, response.textEncodingName);
			if (strData == null) {
				strData = new String(data = this.data, encoding = String.Encoding.utf8);
				// utf8 如果失败了，就用ascii，几率很小。
				if (strData == null) {
					strData = new String(data = this.data, encoding = String.Encoding.ascii);
				}
			}

			let successResult : UploadFileSuccess = {
				data: strData ?? "",
				statusCode: response.statusCode
			}
			let success = kParam?.success;
			let complete = kParam?.complete;
			success?.(successResult);
			complete?.(successResult);
		} catch (e) {
		}
		this.progressListeners.splice(0, this.progressListeners.length)
	}

	onFail(error : NSError) : void {
		let kParam = this.param;
		let code = (error as NSError).code;
		let errCode = code;
		let cause = error.localizedDescription;
		if (code == -1001) {
			errCode = 5;
		} else if (code == -1004) {
			errCode = 1000;
		} else if (code == -1009) {
			errCode = 600003;
		} else {
			errCode = 602001;
		}

		let failResult = new UploadFileFailImpl(getErrcode(Number.from(errCode)));
		failResult.cause = new SourceError(cause);
		let fail = kParam?.fail;
		let complete = kParam?.complete;
		fail?.(failResult);
		complete?.(failResult);
		this.progressListeners.splice(0, this.progressListeners.length)
	}


	private readStringFromData(data : Data, type : string | null) : string | null {
		let result : string | null = null;
		let finalType = type;
		if (finalType == null || finalType!.length == 0) {
			finalType = "utf-8";
		}

		let cfEncoding = CFStringConvertIANACharSetNameToEncoding(finalType as CFString);
		if (cfEncoding != kCFStringEncodingInvalidId) {
			let stringEncoding = CFStringConvertEncodingToNSStringEncoding(cfEncoding);
			let encode = new String.Encoding(rawValue = stringEncoding);
			result = new String(data = data, encoding = encode);
		}
		return result;
	}
}

class DownloadNetworkListener implements NetworkDownloadFileListener {
	public options : DownloadFileOptions | null = null;
	public progressListeners : Array<DownloadFileProgressUpdateCallback> = [];
	private data : Data = new Data();

	constructor(options : DownloadFileOptions) {
		this.options = options;
		super();
	}

	onProgress(progressUpdate : OnProgressDownloadResult) {
		if (this.progressListeners.length != 0) {
			for (let i = 0; i < this.progressListeners.length; i++) {
				let listener = this.progressListeners[i];
				listener(progressUpdate)
			}
		}
	}

	onFinished(response : HTTPURLResponse, filePath: string) : void {
		try {
			let kParam = this.options;
			let tmp : DownloadFileSuccess = {
				tempFilePath:filePath,
				statusCode: response.statusCode
			};
			let success = kParam?.success;
			let complete = kParam?.complete;
			success?.(tmp);
			complete?.(tmp);
		} catch (e) {
		}
		this.progressListeners.splice(0, this.progressListeners.length)
	}

	onFail(error : NSError) : void {
		let kParam = this.options;
		let code = (error as NSError).code;
		let errCode = code;
		let cause = error.localizedDescription;
		if (code == -1001) {
			errCode = 5;
		} else if (code == -1004) {
			errCode = 1000;
		} else if (code == -1009) {
			errCode = 600003;
		} else {
			errCode = 602001;
		}

		let failResult = new DownloadFileFailImpl(getErrcode(Number.from(errCode)));
		failResult.cause = new SourceError(cause);
		let fail = kParam?.fail;
		let complete = kParam?.complete;
		fail?.(failResult);
		complete?.(failResult);
		this.progressListeners.splice(0, this.progressListeners.length)
	}
}


export const request : Request = (options : RequestOptions) : RequestTask => {
	return NetworkManager.getInstance().request(options, new SimpleNetworkListener(options));
}

export const uploadFile : UploadFile = (options : UploadFileOptions) : UploadTask => {
	return NetworkManager.getInstance().uploadFile(options, new UploadNetworkListener(options));
}

export const downloadFile : DownloadFile = (options : DownloadFileOptions) : DownloadTask => {
	return NetworkManager.getInstance().downloadFile(options, new DownloadNetworkListener(options));
}