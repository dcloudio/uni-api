import { API_GET_RECORDER_MANAGER } from '../protocol.uts';
import { GetRecorderManager, RecorderManager, RecorderManagerOnStopResult, RecorderManagerStartOptions } from '../interface.uts';
import AVRecorder, { supportFormats as avRecorderSupportFormats } from './AVRecorder.uts';
import { onRecorderStateChange, setRecordStateCallback, StateChangeRes } from './utils.uts';

  // NOTE 避免被 vue Proxy 污染
let RECORDER_MANAGER: RecorderManager | null = null

class RecorderManagerImpl implements RecorderManager {
  start(options: RecorderManagerStartOptions): void {
    if (!options.format) options.format = 'aac'

    const DEFAULT_DURATION = 1000 * 60
    const MAX_DURATION = DEFAULT_DURATION * 10
    if (typeof options.duration === 'undefined' || options.duration === null) {
      options.duration = DEFAULT_DURATION
    }
    if (options.duration > MAX_DURATION) {
      options.duration = MAX_DURATION
    }

    if (avRecorderSupportFormats.includes(options.format ?? '')) {
      RECORDER_MANAGER = new AVRecorder()
    }
    if (RECORDER_MANAGER) {
      RECORDER_MANAGER.start(options)
    } else {
      onRecorderStateChange('error', { errMsg: `format not supported. Only supported ${avRecorderSupportFormats.join(',')}` } as StateChangeRes)
    }
  }
  pause(): void {
    if (RECORDER_MANAGER) RECORDER_MANAGER.pause()
  }
  resume(): void {
    if (RECORDER_MANAGER) RECORDER_MANAGER.resume()
  }
  async stop() {
    if (RECORDER_MANAGER) {
      try {
        await RECORDER_MANAGER.stop()
      } catch (error) { }
      RECORDER_MANAGER = null
    }
  }
  onStart(options: (result: any) => void): void {
    setRecordStateCallback('start', options)
  }
  onPause(options: (result: any) => void): void {
    setRecordStateCallback('pause', options)
  }
  onStop(options: (result: RecorderManagerOnStopResult) => void): void {
    setRecordStateCallback('stop', options)
  }
  onFrameRecorded(options: (result: any) => void): void {
    setRecordStateCallback('frameRecorded', options)
  }
  onError(options: (result: any) => void): void {
    setRecordStateCallback('error', options)
  }
  onResume(options: (result: any) => void): void {
    setRecordStateCallback('resume', options)
  }
  onInterruptionBegin(options: (result: any) => void): void {
    setRecordStateCallback('interruptionBegin', options)
  }
  onInterruptionEnd(options: (result: any) => void): void {
    setRecordStateCallback('interruptionEnd', options)
  }
}

let recorderManager: RecorderManager | null = null

export const getRecorderManager: GetRecorderManager = defineSyncApi<RecorderManager>(
  API_GET_RECORDER_MANAGER,
  (): RecorderManager => {
    if (recorderManager) return recorderManager
    else recorderManager = new RecorderManagerImpl()
    return recorderManager
  }
) as GetRecorderManager
